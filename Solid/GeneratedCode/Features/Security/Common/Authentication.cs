////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
//////////////////////////////////////////////////////////////////////////////////////////// 
using System;
using System.Collections.Generic;
using System.Configuration;
using System.IdentityModel.Protocols.WSTrust;
using System.IdentityModel.Tokens;
using System.Linq;
using System.Reflection;
using System.Security.Claims;
using System.Security.Cryptography;
using System.ServiceModel.Security.Tokens;
using System.Text;
using System.Threading.Tasks;
using System.Web;
using System.Net;
using System.Web.Configuration;
using Unity;
using Solid.BusinessLayer.ORMSupportClasses;
using Solid.Data.DataObjects;
using GenerativeObjects.Practices.LayerSupportClasses;
using GenerativeObjects.Practices.ExceptionHandling;
using GenerativeObjects.Practices.LayerSupportClasses.Features.Security.Common;
using GenerativeObjects.Practices.LayerSupportClasses.Features.Threading;
using GenerativeObjects.Practices.LayerSupportClasses.ServiceLayer.Http;



namespace Solid.Feature.Security.Common
{   
    public class Authentication : IAuthentication
    {
        // Secret key to sign the JWT Token
        private static byte[] _secretKey = null;

        private static byte[] _SecretKey
        {
            get
            {
                if (_secretKey == null)
                {
                    // get machine key
                    Configuration config = WebConfigurationManager.OpenWebConfiguration(HttpContext.Current.Request.ApplicationPath);
                    MachineKeySection key = (MachineKeySection)config.GetSection("system.web/machineKey");

                    if (key.DecryptionKey.StartsWith("AutoGenerate"))
                    {
                        // Get the generated machine key. Must use relection because the generated decryption key is an internal field
                        BindingFlags flags =
                              BindingFlags.Instance |
                              BindingFlags.NonPublic |
                              BindingFlags.GetProperty;

                        Func<string, byte[] > propertyReader = name => (byte[])key
                            .GetType()
                            .GetProperty(name, flags)
                            .GetValue(key, null);

                        _secretKey = propertyReader("DecryptionKeyInternal");
                    }
                    else
                        _secretKey = System.Text.Encoding.ASCII.GetBytes(key.DecryptionKey);
                }

                return _secretKey;
            }
        }

        // Create a new JWT token with specific claims and expiration date
        public string CreateToken(IEnumerable<Claim> claims, DateTime? expirationDate = null)
        {
            var tokenHandler = new JwtSecurityTokenHandler();

            var now = DateTime.UtcNow;
            var tokenDescriptor = new SecurityTokenDescriptor
            {
                Subject = new ClaimsIdentity(claims),
                TokenIssuerName = "self",
                AppliesToAddress = "http://www.generativeobjects.com",
                Lifetime = new Lifetime(now, expirationDate ?? now.AddMinutes(Convert.ToInt32(ConfigurationManager.AppSettings["SessionTokenTimeout"]))),
                SigningCredentials = new SigningCredentials(
                    new InMemorySymmetricSecurityKey(_SecretKey),
                    "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256",
                    "http://www.w3.org/2001/04/xmlenc#sha256"),


            };

            var token = tokenHandler.CreateToken(tokenDescriptor);

            var tokenString = tokenHandler.WriteToken(token);

            return tokenString;
        }

        // Create a cookie to hold the JWT token 
        public void AddTokenToCookies(string token)
        {
            var bearerCookie = new HttpCookie("BearerToken", token);
            var baseUrl = GenerativeObjects.Practices.HttpUtilities.GetApplicationBaseUrl().TrimEnd('/');
            var path = GenerativeObjects.Practices.HttpUtilities.GetUrlPath(baseUrl);
            bearerCookie.Path = path;
            // bearerCookie.HttpOnly = true; // Preventing JS access to the cookie value
			
			// Making sure we don't re-add the same cookie twice (but replace it)
            if (HttpContext.Current.Response.Cookies.AllKeys.Contains("BearerToken"))
            {
                HttpContext.Current.Response.Cookies.Set(bearerCookie);
            }
            else
            {
                HttpContext.Current.Response.Cookies.Add(bearerCookie);
            }
		}

        // Create an authorization header to hold the JWT token 
        public void AddTokenToAuthorizationHeaders(string token)
        {
            HttpContext.Current.Response.Headers["Authorization"] = "Bearer " + token;
        }

        // Get the current JWT token and transport type
        public string GetBearerToken(HttpContext context, out BearerTokenTransport tokenTransport)
        {
            string token;

			// If context is null, might be a worker thread (Task), so check for the token in the per-thread IUserIdentity
			if (context == null)
			{
				tokenTransport = BearerTokenTransport.ThreadUserIdentity;
				token = ApplicationSettings.Container.Resolve<IThreadContext>().UserToken;
				return token;
			}

            // try get from Authentication headers
            token = context.Request.Headers["Authorization"];

            if (token != null && token.StartsWith("Bearer "))
            {
                tokenTransport = BearerTokenTransport.AuthorizationHeader;
                return token.Substring("Bearer ".Length, token.Length - "Bearer ".Length);
            }

            // fall back to API parameter
            token = context.Request["_user_token"];
            if (token != null)
            {
                tokenTransport = BearerTokenTransport.APIParameter;
                return token;
            }

            // fall back to cookies
            var cookies = HttpContext.Current.Request.Cookies;
            token = cookies["BearerToken"] == null ? null : cookies["BearerToken"].Value;

            tokenTransport = BearerTokenTransport.Cookie;
            return token;
        }

        // Validate a token with autorenew if required
        public ClaimsPrincipal ValidateTokenAndAutoRenewTokenIfRequired(string bearerToken, BearerTokenTransport tokenTransport)
        {
            try
            {
                var principal = ValidateToken(bearerToken);

 
                var expirationDate = GetTokenExpirationDate(bearerToken);

                var sessionTokenTimeout = Convert.ToInt32(ConfigurationManager.AppSettings["SessionTokenTimeout"]);
                var sessionTokenRenewalTimeout = Convert.ToInt32(ConfigurationManager.AppSettings["SessionTokenRenewalTimeout"]);

                if (tokenTransport != BearerTokenTransport.APIParameter && DateTime.Compare(DateTime.UtcNow, expirationDate.AddMinutes(sessionTokenRenewalTimeout - sessionTokenTimeout)) > 0)
                {
                    var token = CreateToken(principal.Claims.Where(c => c.Type != "aud" && c.Type != "iss" && c.Type != "nbf" && c.Type != "exp"));

					switch (tokenTransport)
					{
						case BearerTokenTransport.AuthorizationHeader:
							AddTokenToAuthorizationHeaders(token);
							break;
						case BearerTokenTransport.Cookie:
							AddTokenToCookies(token);
							break;
						case BearerTokenTransport.APIParameter:
							// nothing we can do in this case
							break;
						case BearerTokenTransport.ThreadUserIdentity:
							ApplicationSettings.Container.Resolve<IThreadContext>().UserToken = token;
							break;
						default:
							// so that we don't miss this if any other means of token transport arrive on the scene in the future
							throw new GOServerException("notImplemented", $"{tokenTransport} - AutoRenewToken has not been implemented for this kind of token transport");
					}
                }

                return principal;
            }
            catch (Exception)
            {
                // We used to age-out the cookie here. 
				// Removed because we want expired tokens to continue to stick around so that the rest of the app knows the context for auth failure
                throw;
            }
        }

        // Valide a JWT token and extract claims
        public ClaimsPrincipal ValidateToken(string tokenString)
        {
            var tokenHandler = new JwtSecurityTokenHandler();

            var validationParameters = new TokenValidationParameters()
            {
                AllowedAudience = "http://www.generativeobjects.com",
                SigningToken = new BinarySecretSecurityToken(_SecretKey),
                ValidIssuer = "self"
            };

			ClaimsPrincipal principal = null;

			try
			{
				// The following throws an exception if token not validated
				principal = tokenHandler.ValidateToken(tokenString, validationParameters);
			}
			catch (Exception)
			{
				// If token has expired, throw specific exception so callers can know this
				if (HasTokenExpired(tokenString))
				{
					throw new System.ServiceModel.Security.ExpiredSecurityTokenException();
                }

				throw;
			}

			// Double-check the token expiry. The tokenHandler.ValidateToken() call seems to be 5-min clock-skewed.
			if (HasTokenExpired(tokenString))
			{
				throw new System.ServiceModel.Security.ExpiredSecurityTokenException();
			}

			return principal;
        }

		public bool HasTokenExpired(string encodedToken)
		{
			DateTime expiry = GetTokenExpirationDate(encodedToken);
			return (DateTime.UtcNow - expiry).TotalSeconds > 0;
		}

        // Extract expiration date from token
        public DateTime GetTokenExpirationDate(string encodedToken)
        {
            var tokenHandler = new JwtSecurityTokenHandler();
            var token = tokenHandler.ReadToken(encodedToken);
            return token.ValidTo;
        }
        // Get currently connected user claims
        public UserClaims GetCurrentUserClaims()
        {
            BearerTokenTransport tokenTransport;
            var bearerToken = GetBearerToken(HttpContext.Current, out tokenTransport);
            var result = new UserClaims();

            // no connected user, or was connected and timed out
            if (String.IsNullOrEmpty(bearerToken) || HasTokenExpired(bearerToken))
            {
                // Find out roles associated to anonymous users 
                var anonymousGroup = ApplicationSettings.Container.Resolve<IDataFacade>().GOGroupDataProvider.GetCollection(null, String.Format("IsSpecialGroup == true && SpecialGroup == {0} ", (int)GOSpecialGroupsEnum.AnonymousUsers), includes: new List<string>() { "GroupRoleItems" }, skipSecurity : true).SingleOrDefault();

                result.IsAuthenticated = false;
                result.UserId = null;
                result.UserName = null;

                if (anonymousGroup != null)
                    result.Roles = anonymousGroup.GroupRoleItems.Select(gr => gr.GORoleName).Distinct().ToList();
                else
                    result.Roles = new List<string>();

                return result;
            }

            ClaimsPrincipal principal;
            principal = ValidateTokenAndAutoRenewTokenIfRequired(bearerToken, tokenTransport);

			var userid = Guid.Parse(principal.Claims.Where(c => c.Type == "UserId").Single().Value.ToString());
            string userName = principal.Claims.Where(c => c.Type == ClaimTypes.Name).Single().Value.ToString();
            var roles = principal.Claims.Where(c => c.Type == ClaimTypes.Role).Single().Value.ToString();

            result.IsAuthenticated = true;
            result.UserId = userid;
            result.UserName = userName;
            result.Roles = roles.Split(',').ToList();

			return result;
        }

		public bool IsCurrentUserTokenExpired
		{
			get
			{
				BearerTokenTransport tokenTransport;
				var bearerToken = GetBearerToken(HttpContext.Current, out tokenTransport);
				return bearerToken != null && HasTokenExpired(bearerToken);
			}
		}   

		public void ThrowAccessDenied(GOServerException exception)
		{
			// If is an anonymous caller and the current user token has expired, package the authorization exception inside a expiredSecurityToken exception
			// makes for a more meaningful response to caller
			var claims = GetCurrentUserClaims();

			if (claims != null
				&& claims.IsAnonymousClaim
				&& IsCurrentUserTokenExpired)
			{
				throw new GOServerException("expiredSecurityToken", "expiredSecurityToken", exception, (int)HttpStatusCode.Forbidden);
			}
			else
			{
				throw exception;
			}
		}
    
		public string ExplainAccessDenied(EntityAccessEnum change, string entityDisplayName)
		{
			switch (change)
			{
				case EntityAccessEnum.READ:
					return $"Access denied: You're not authorized to view this {entityDisplayName} data";

				case EntityAccessEnum.CREATE:
					return $"Access denied: You're not authorized to create this {entityDisplayName} data";

				case EntityAccessEnum.UPDATE:
					return $"Access denied: You're not authorized to modify this {entityDisplayName} data";

				case EntityAccessEnum.DELETE:
					return $"Access denied: You're not authorized to delete this {entityDisplayName} data";
						
				default:
					return "Access denied";
			}
		}

		
	}
}