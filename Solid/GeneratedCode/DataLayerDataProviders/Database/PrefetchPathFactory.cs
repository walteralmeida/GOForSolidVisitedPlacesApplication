////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
//////////////////////////////////////////////////////////////////////////////////////////// 
/*using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Linq;
using System.IO;
using System.Xml;
using System.Reflection;
using SD.LLBLGen.Pro.ORMSupportClasses;
using SD.LLBLGen.Pro.LinqSupportClasses;
using Solid.Data;
using Solid.Data.Linq;

namespace Solid.Data.DataProviders.Database
{    
	public static class PrefetchPathFactory
    {

		// Lock Used during the initialization of PathNodes.
		private static Object _lockObject = new Object();

        private struct PathNode
        {
            public string ParentEntityName;
            public string EntityName;
            public string PathName;

            public List<PathNode> PathNodes { get; set; }
        }

        private static Dictionary<string, Dictionary<string, PathNode>> _pathNodes;

        private static Dictionary<string, Dictionary<string, PathNode>> PathNodes
        {
            get
            {
				lock(_lockObject)
				{
					if (_pathNodes == null)
					{

                    _pathNodes = new Dictionary<string,Dictionary<string,PathNode>>();
					_pathNodes.Add ( "gorole", new Dictionary<string,PathNode>());

					_pathNodes["gorole"].Add( "grouproleitems", new PathNode { EntityName = "GOGroupRole", PathName = "GroupRoleItems" });
					_pathNodes["gorole"].Add( "userroleitems", new PathNode { EntityName = "GOUserRole", PathName = "UserRoleItems" });
					_pathNodes.Add ( "gogrouprole", new Dictionary<string,PathNode>());

					_pathNodes["gogrouprole"].Add( "group", new PathNode { EntityName = "GOGroup", PathName = "Group" });
					_pathNodes["gogrouprole"].Add( "role", new PathNode { EntityName = "GORole", PathName = "Role" });
					_pathNodes.Add ( "place", new Dictionary<string,PathNode>());

					_pathNodes["place"].Add( "country", new PathNode { EntityName = "Country", PathName = "Country" });
					_pathNodes["place"].Add( "placetolocationitems", new PathNode { EntityName = "PlaceToLocation", PathName = "PlaceToLocationItems" });
					_pathNodes.Add ( "location", new Dictionary<string,PathNode>());

					_pathNodes["location"].Add( "country", new PathNode { EntityName = "Country", PathName = "Country" });
					_pathNodes["location"].Add( "placetolocationitems", new PathNode { EntityName = "PlaceToLocation", PathName = "PlaceToLocationItems" });
					_pathNodes.Add ( "placetolocation", new Dictionary<string,PathNode>());

					_pathNodes["placetolocation"].Add( "location", new PathNode { EntityName = "Location", PathName = "Location" });
					_pathNodes["placetolocation"].Add( "place", new PathNode { EntityName = "Place", PathName = "Place" });
					_pathNodes.Add ( "gouser", new Dictionary<string,PathNode>());

					_pathNodes["gouser"].Add( "userroleitems", new PathNode { EntityName = "GOUserRole", PathName = "UserRoleItems" });
					_pathNodes["gouser"].Add( "usergroupitems", new PathNode { EntityName = "GOUserGroup", PathName = "UserGroupItems" });
					_pathNodes.Add ( "gogroup", new Dictionary<string,PathNode>());

					_pathNodes["gogroup"].Add( "usergroupitems", new PathNode { EntityName = "GOUserGroup", PathName = "UserGroupItems" });
					_pathNodes["gogroup"].Add( "grouproleitems", new PathNode { EntityName = "GOGroupRole", PathName = "GroupRoleItems" });
					_pathNodes.Add ( "gouserrole", new Dictionary<string,PathNode>());

					_pathNodes["gouserrole"].Add( "role", new PathNode { EntityName = "GORole", PathName = "Role" });
					_pathNodes["gouserrole"].Add( "user", new PathNode { EntityName = "GOUser", PathName = "User" });
					_pathNodes.Add ( "country", new Dictionary<string,PathNode>());

					_pathNodes["country"].Add( "placeitems", new PathNode { EntityName = "Place", PathName = "PlaceItems" });
					_pathNodes["country"].Add( "locationitems", new PathNode { EntityName = "Location", PathName = "LocationItems" });
					_pathNodes.Add ( "gousergroup", new Dictionary<string,PathNode>());

					_pathNodes["gousergroup"].Add( "group", new PathNode { EntityName = "GOGroup", PathName = "Group" });
					_pathNodes["gousergroup"].Add( "user", new PathNode { EntityName = "GOUser", PathName = "User" });
					}
				}

                return _pathNodes;
            }
        }

		private static Dictionary<string,string> _entityRelations = new Dictionary<string,string>()
        {
          { "gorole", "GroupRoleItems, UserRoleItems" },
          { "gogrouprole", "Group, Role" },
          { "place", "Country, PlaceToLocationItems" },
          { "location", "Country, PlaceToLocationItems" },
          { "placetolocation", "Location, Place" },
          { "gouser", "UserRoleItems, UserGroupItems" },
          { "gogroup", "UserGroupItems, GroupRoleItems" },
          { "gouserrole", "Role, User" },
          { "country", "PlaceItems, LocationItems" },
          { "gousergroup", "Group, User" },
      };

        private static Dictionary<string, string> EntityRelations 
		{
			get
			{
				return _entityRelations;
			}
		}
		
		private static List<string> DatabaseEntities = new List<string>()
        {
			"GOGroupRole", "GOUser", "GOGroup", "GOUserRole", "GOUserGroup", "GOLoginHistory" 
        };

		private static Dictionary<string, string> EntityNames = new Dictionary<string, string> { { "country", "Country" }, { "gogroup", "GOGroup" }, { "gogrouprole", "GOGroupRole" }, { "gologinhistory", "GOLoginHistory" }, { "gorole", "GORole" }, { "gouser", "GOUser" }, { "gousergroup", "GOUserGroup" }, { "gouserrole", "GOUserRole" }, { "location", "Location" }, { "place", "Place" }, { "placetolocation", "PlaceToLocation" } };

        private static PathNode GetPathNode(string entityName, string relationName)
        {
            bool hierarchicalRelation = relationName.Contains(":");
            entityName = hierarchicalRelation ? relationName.Split(':')[0].ToLower() : entityName.ToLower(); 
            //TODO : test concreteEntityName is sub type of entityName
            relationName = hierarchicalRelation ? relationName.Split(':')[1].ToLower() : relationName.ToLower(); 

            if (!PathNodes.ContainsKey(entityName))
                throw new ArgumentException(String.Format("{0} entity has no relation named {1}. Possible relations are : {2}", entityName, relationName, "none"));

            if (!PathNodes[entityName].ContainsKey(relationName))
                throw new ArgumentException(String.Format("{0} entity has no relation named {1}. Possible relations are : {2}", entityName, relationName, EntityRelations[entityName]));

            var result = PathNodes[entityName][relationName];
            result.ParentEntityName = EntityNames[entityName];

            return result;
        }

        public static List<IPathEdge> ConstructPrefetchPath(string entityname, List<string> includeList)
        {
			if (includeList == null) 
            {
				return null;
            }

			var unhandledIncludes = new List<string>();

            var pathNodeGraph = new PathNode { EntityName = entityname, ParentEntityName = entityname, PathName = null, PathNodes = new List<PathNode>() };
            
            foreach (var include in includeList)
            {
                var currentEntity = entityname;
                var currentPathNodeList = pathNodeGraph.PathNodes;
				int count = 0;
				var includeparts = include.Split('.');

                foreach (var includepart in includeparts)
                {
                    var pathNode = GetPathNode(currentEntity, includepart);

                    if (!DatabaseEntities.Contains(pathNode.EntityName))
                    {
                        // not a entity with database datasource => prefetch path cannot be covered    

                        //HACK GO-756: we only now how to dispatch unhandled prefetch paths of level 0 ... should be possible at any level. Workaround if at level > 0 : we say the full include is not covered
                        // which mean some data will be retrieved more than once from database
                        
                        string unhandledInclude = String.Join(".", includeparts.Skip(/*HACK : should skip count* / 0));
                        unhandledIncludes.Add(unhandledInclude);
                        break;
                    }

                    if (currentPathNodeList.Where(n => n.EntityName == pathNode.EntityName && n.PathName == pathNode.PathName).Any())
                    {
                        currentPathNodeList = currentPathNodeList.Where(n => n.EntityName == pathNode.EntityName && n.PathName == pathNode.PathName).Single().PathNodes;
                    }
                    else
                    {
                        pathNode.PathNodes = new List<PathNode>();
                        currentPathNodeList.Add(pathNode);
                        currentPathNodeList = pathNode.PathNodes;
                    }
                    
                    currentEntity = pathNode.EntityName;
                }

            }
                
            includeList.Clear();
            includeList.AddRange(unhandledIncludes);

            return ConstructPrefetchPath(pathNodeGraph);
        }


        private static List<IPathEdge> ConstructPrefetchPath(PathNode pathNodeGraph)
        {
            var pathEdges = new List<IPathEdge>();

            {
                foreach (var pathNode in pathNodeGraph.PathNodes)
                {
                    var nonDatabaseData = false; //TODO
                    // Ignore nonDatabaseData data prefetch 
                    if (nonDatabaseData) continue;

                    var pathEdge = CreatePathEdge(pathNode.ParentEntityName, pathNode.EntityName, pathNode.PathName, ConstructPrefetchPath(pathNode));
                    pathEdges.Add(pathEdge);
                }
            }
            
            return pathEdges;        
        }


        private static IPathEdge CreatePathEdge(string rootEntityName, string prefetchEntityName, string path, List<IPathEdge> pathEdges) 
        {
            var prefetchEntityType = (EntityType)(Enum.Parse(typeof(EntityType),String.Concat(prefetchEntityName,"Entity")));
            var typeInfo = Type.GetType("Solid.Data.EntityClasses." + rootEntityName + "Entity, Solid.Data");
            var prefetchPathPropertyInfo = typeInfo.GetProperty(String.Concat("PrefetchPath", path), BindingFlags.FlattenHierarchy | BindingFlags.Public | BindingFlags.Static);
            var prefetchPath = (IPrefetchPathElementCore)prefetchPathPropertyInfo.GetValue(null, null);

            switch (prefetchEntityType)
            {
				case EntityType.CountryEntity:
					return new PathEdge<CountryEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GOGroupEntity:
					return new PathEdge<GOGroupEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GOGroupRoleEntity:
					return new PathEdge<GOGroupRoleEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GOLoginHistoryEntity:
					return new PathEdge<GOLoginHistoryEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GORoleEntity:
					return new PathEdge<GORoleEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GOUserEntity:
					return new PathEdge<GOUserEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GOUserGroupEntity:
					return new PathEdge<GOUserGroupEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.GOUserRoleEntity:
					return new PathEdge<GOUserRoleEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.LocationEntity:
					return new PathEdge<LocationEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.PlaceEntity:
					return new PathEdge<PlaceEntity>(prefetchPath, pathEdges.ToArray());
				case EntityType.PlaceToLocationEntity:
					return new PathEdge<PlaceToLocationEntity>(prefetchPath, pathEdges.ToArray());
            }
			
			return null;
		}
	}
}*/