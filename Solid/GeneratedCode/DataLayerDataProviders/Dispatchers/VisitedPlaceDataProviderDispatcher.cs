
////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
//////////////////////////////////////////////////////////////////////////////////////////// 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Dynamic;
using System.Text;
using System.Threading.Tasks;
using Unity;
using Unity.Attributes;
using GenerativeObjects.Practices.LayerSupportClasses.DataLayer;
using GenerativeObjects.Practices.ORMSupportClasses;
using GenerativeObjects.Practices.ExceptionHandling;
using GenerativeObjects.Practices.LayerSupportClasses;
using Solid.Data.DataObjects;
using Solid.Data.DataProviders.Database;

namespace Solid.Data.DataProviders.Dispatchers
{
    public class VisitedPlaceDataProviderDispatcher : IDataProviderDispatcher<VisitedPlaceDataObject>
    {
		[Dependency]   
		public IDataProvider<UserProfileDataObject> UserProfileDataProvider { get; set; }        
		[Dependency]   
		public IDataProvider<CountryDataObject> CountryDataProvider { get; set; }        
		[Dependency]   
		public IDataProvider<PlaceDataObject> PlaceDataProvider { get; set; }        

        public void DispatchForEntity(VisitedPlaceDataObject entity, List<string> includes, IObjectsDataSet context, Dictionary<string, object> parameters, bool skipSecurity = false)
        {
			// Remember includes we've already dispatched so as to avoid multiple data fetches
			var dispatched = new HashSet<string>();

			// get (custom) prefetch list so we can skip the dispatch for stuff we already fetched
			var prefetches = PrefetchAssociations.Get("VisitedPlace", parameters);

            foreach (var include in includes)
            {
	
					string relation = include.Split('.').First().ToLower();
					var subincludes = DispatchPath.GetSubIncludes(relation, includes);

					if (relation.Contains(":"))
						relation = relation.Substring(relation.IndexOf(':') + 1);

					if (dispatched.Contains(relation))
						continue;

					dispatched.Add(relation);

					switch (relation)
					{
                  case "userprofile":
							{
								// custom code can implement IPrefetch<ORMVisitedPlace> and add prefetch info through PrefetchAssociations helper => if set, we skip the dispatch-fetch
								if (prefetches.Contains("UserProfile"))
									break;

								try
								{
									var objectToFetch = UserProfileDataProvider.Get(new UserProfileDataObject(entity.UserProfileUri), null, subincludes, context, parameters, skipSecurity);
									if(objectToFetch != null) 
									{
										entity.ObjectsDataSet.Merge(objectToFetch.ObjectsDataSet);
									}
								}
								catch (GOServerException e)
								{
									if (e.Reason != "accessDenied")
										throw;
								}
								break;
							}
                  case "country":
							{
								// custom code can implement IPrefetch<ORMVisitedPlace> and add prefetch info through PrefetchAssociations helper => if set, we skip the dispatch-fetch
								if (prefetches.Contains("Country"))
									break;

								if (entity.CountryURI != null) 
								{
									try
									{
										var objectToFetch = CountryDataProvider.Get(new CountryDataObject((System.String)entity.CountryURI), null, subincludes, context, parameters, skipSecurity);
										if (objectToFetch != null) 
										{
											entity.ObjectsDataSet.Merge(objectToFetch.ObjectsDataSet);
										}
									}
									catch (GOServerException e)
									{
										if (e.Reason != "accessDenied")
											throw;
									}
								}
								break;
							}
                  case "place":
							{
								// custom code can implement IPrefetch<ORMVisitedPlace> and add prefetch info through PrefetchAssociations helper => if set, we skip the dispatch-fetch
								if (prefetches.Contains("Place"))
									break;

								if (entity.PlaceURI != null) 
								{
									try
									{
										var objectToFetch = PlaceDataProvider.Get(new PlaceDataObject((System.String)entity.PlaceURI), null, subincludes, context, parameters, skipSecurity);
										if (objectToFetch != null) 
										{
											entity.ObjectsDataSet.Merge(objectToFetch.ObjectsDataSet);
										}
									}
									catch (GOServerException e)
									{
										if (e.Reason != "accessDenied")
											throw;
									}
								}
								break;
							}
						default:
							throw new ApplicationException("VisitedPlace Entity has no relation named " + relation);
					}
          }        
		}

        public void DispatchForEntityCollection(IEnumerable<VisitedPlaceDataObject> entities, List<string> includes, IObjectsDataSet context, Dictionary<string, object> parameters, bool skipSecurity = false)
        {
			// Remember includes we've already dispatched so as to avoid multiple data fetches
			var dispatched = new HashSet<string>();

			// get (custom) prefetch list so we can skip the dispatch for stuff we already fetched
			var prefetches = PrefetchAssociations.Get("VisitedPlace", parameters);

            foreach (var include in includes)
            {
					string relation = include.Split('.').First().ToLower();
					var subincludes = DispatchPath.GetSubIncludes(relation, includes);

					if (relation.Contains(":"))
						relation = relation.Substring(relation.IndexOf(':') + 1);

					if (dispatched.Contains(relation))
						continue;

					dispatched.Add(relation);

					switch (relation)
					{
						case "userprofile":
                        {
							// custom code can implement IPrefetch<ORMVisitedPlace> and add prefetch info through PrefetchAssociations helper => if set, we skip the dispatch-fetch
							if (prefetches.Contains("UserProfile"))
								break;

							var filterparameters = new object[] { entities.Select(e => e.UserProfileUri).Distinct().ToArray() } ;
							try
							{
								entities.First().ObjectsDataSet.Merge(UserProfileDataProvider.GetCollection(null, "(@0.Contains(outerIt.Uri))", filterparameters, null, 0, 0, subincludes, context, parameters, skipSecurity).ObjectsDataSet);
							}
							catch (GOServerException e)
							{
								if (e.Reason != "accessDenied")
									throw;
							}
							break;
						}
						case "country":
                        {
							// custom code can implement IPrefetch<ORMVisitedPlace> and add prefetch info through PrefetchAssociations helper => if set, we skip the dispatch-fetch
							if (prefetches.Contains("Country"))
								break;

							var filterparameters = new object[] { entities.Where(e => e.CountryURI != null).Select(e => (System.String)e.CountryURI).Distinct().ToArray() } ;
							try
							{
								entities.First().ObjectsDataSet.Merge(CountryDataProvider.GetCollection(null, "(@0.Contains(outerIt.URI))", filterparameters, null, 0, 0, subincludes, context, parameters, skipSecurity).ObjectsDataSet);
							}
							catch (GOServerException e)
							{
								if (e.Reason != "accessDenied")
									throw;
							}
							break;
						}
						case "place":
                        {
							// custom code can implement IPrefetch<ORMVisitedPlace> and add prefetch info through PrefetchAssociations helper => if set, we skip the dispatch-fetch
							if (prefetches.Contains("Place"))
								break;

							var filterparameters = new object[] { entities.Where(e => e.PlaceURI != null).Select(e => (System.String)e.PlaceURI).Distinct().ToArray() } ;
							try
							{
								entities.First().ObjectsDataSet.Merge(PlaceDataProvider.GetCollection(null, "(@0.Contains(outerIt.URI))", filterparameters, null, 0, 0, subincludes, context, parameters, skipSecurity).ObjectsDataSet);
							}
							catch (GOServerException e)
							{
								if (e.Reason != "accessDenied")
									throw;
							}
							break;
						}
                  default:
                        throw new ApplicationException("VisitedPlace Entity has no relation named " + relation);
					}
            }        
        }
	}
}