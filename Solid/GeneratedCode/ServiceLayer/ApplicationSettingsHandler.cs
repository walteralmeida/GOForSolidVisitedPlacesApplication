////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
//////////////////////////////////////////////////////////////////////////////////////////// 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Net;
using System.Web;
using System.IO;
using System.IO.Compression;
using System.Text.RegularExpressions;
using GenerativeObjects.Practices.DependencyInjection;
using GenerativeObjects.Practices.Settings;
using GenerativeObjects.Practices.ExceptionHandling;
using GenerativeObjects.Practices.ORMSupportClasses;
using System.Web.SessionState;
using System.Configuration;
using GenerativeObjects.Practices.LayerSupportClasses;
using Unity;
using GenerativeObjects.Practices.LayerSupportClasses.ServiceLayer;

namespace Solid.ServiceLayer.WebHandlers
{
    public class ApplicationSettingsHandler : ApiHandler
    {
        public override void DoProcessRequest(HttpContext context)
        {
			try
			{
				context.Response.ContentType = "application/javascript";
				context.Response.ContentEncoding = Encoding.UTF8;

				// Enable GZip Compression if client support it
				var acceptGZip = HttpContext.Current.Request.Headers["Accept-Encoding"] != null && HttpContext.Current.Request.Headers["Accept-Encoding"].Contains("gzip");
				AddGZipCompression(context, acceptGZip);

                var baseUrl = GenerativeObjects.Practices.HttpUtilities.GetApplicationBaseUrl(includeOrigin : false);

                var content = new StringBuilder();
                content.AppendLine("(function () {");

				// we let the client browser set the origin, it case of proxy, the origin on the browser can be different than the server
				content.AppendFormat("Solid.Web.Application.BaseURL = location.origin + \"{0}\";\n", baseUrl);
				
				var sessionTokenTimeoutInSeconds = Convert.ToInt32(ConfigurationManager.AppSettings["SessionTokenTimeout"]) * 60;
				content.AppendFormat("Solid.Web.Application.SessionTokenTimeout = \"{0}\";\n", sessionTokenTimeoutInSeconds);
				
				var sessionNoActivityMessageDelayInSeconds = Convert.ToInt32(ConfigurationManager.AppSettings["SessionNoActivityMessageDelay"]) * 60;
				content.AppendFormat("Solid.Web.Application.SessionNoActivityMessageDelay = \"{0}\";\n", sessionNoActivityMessageDelayInSeconds);
				var injectLogging = ConfigurationManager.AppSettings["ActivateClientLogging"];
                bool loggingEnabled;
                if (!Boolean.TryParse(injectLogging, out loggingEnabled))
                    loggingEnabled = false; 
				content.AppendFormat("GenerativeObjects.Web.ActivateClientLogging = {0};\n", loggingEnabled.ToString().ToLower());

              content.AppendLine("} ());");

                context.Response.Write(content.ToString());
			}
			finally
			{
			}
        }
		
		/// <summary>
		/// If the request indicate that it allow to server to send GZip data, add the proper header.
		/// </summary>
		public static void AddGZipCompression(HttpContext context, bool acceptGZip)
		{
			if (acceptGZip)
			{
				context.Response.Filter = new GZipStream(context.Response.Filter, CompressionMode.Compress);
				HttpContext.Current.Response.AppendHeader("Content-encoding", "gzip");
			} 
		}

        public override bool IsReusable
        {
            // To enable pooling, return true here.
            // This keeps the handler in memory.
            get { return true; }
        }
    }
} 