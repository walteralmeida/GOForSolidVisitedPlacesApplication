////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
//////////////////////////////////////////////////////////////////////////////////////////// 
(function (global) {
    Solid.Web.Application.ViewModel = function (appcontroller) {
        var self = this;

        this.controller = appcontroller;
        this.contextId = [this.controller.getNextContextId()];

        this.pageController = ko.observable(null);
		
		// Connect to custom code if any
		if (Solid.Web.Application.ViewModelCustom !== undefined)
			this.viewModelCustom = new Solid.Web.Application.ViewModelCustom(self);
 
		this.pageTitle = ko.computed(function () {
			return self.pageController() == null ? "" : self.pageController().pageTitle();
        });

		this.navigation = {
			breadCrumbs : ko.observableArray(),			
			isVisitedPlaceEnabled : ko.observable(true),
			isVisitedPlaceVisible : ko.observable(true), 
			isVisitedPlacesEnabled : ko.observable(true),
			isVisitedPlacesVisible : ko.observable(true), 
			isCountryDetailsEnabled : ko.observable(true),
			isCountryDetailsVisible : ko.observable(true), 
			isLocationsEnabled : ko.observable(true),
			isLocationsVisible : ko.observable(true), 
			isUsersEnabled : ko.observable(true),
			isUsersVisible : ko.observable(true), 
			isMyProfileEnabled : ko.observable(true),
			isMyProfileVisible : ko.observable(true), 
			isPlacesEnabled : ko.observable(true),
			isPlacesVisible : ko.observable(true), 
			isUserProfileEnabled : ko.observable(true),
			isUserProfileVisible : ko.observable(true), 
			isPlaceDetailsEnabled : ko.observable(true),
			isPlaceDetailsVisible : ko.observable(true), 
			isLocationDetailsEnabled : ko.observable(true),
			isLocationDetailsVisible : ko.observable(true), 
			isCountriesEnabled : ko.observable(true),
			isCountriesVisible : ko.observable(true) 
		};

		this.navigation.updateMenu = function () {
			self.updateDefaultNavigationNodeVisibility();

			self.navigation.isVisitedPlaceVisible(self.getNodeVisibility('VisitedPlace'));
			self.navigation.isVisitedPlacesVisible(self.getNodeVisibility('VisitedPlaces'));
			self.navigation.isCountryDetailsVisible(self.getNodeVisibility('CountryDetails'));
			self.navigation.isLocationsVisible(self.getNodeVisibility('Locations'));
			self.navigation.isUsersVisible(self.getNodeVisibility('Users'));
			self.navigation.isMyProfileVisible(self.getNodeVisibility('MyProfile'));
			self.navigation.isPlacesVisible(self.getNodeVisibility('Places'));
			self.navigation.isUserProfileVisible(self.getNodeVisibility('UserProfile'));
			self.navigation.isPlaceDetailsVisible(self.getNodeVisibility('PlaceDetails'));
			self.navigation.isLocationDetailsVisible(self.getNodeVisibility('LocationDetails'));
			self.navigation.isCountriesVisible(self.getNodeVisibility('Countries'));
			
			// Custom updates (to override generated behavior in case of complex rules)
			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsVisitedPlaceEnabled !== undefined) 
				self.viewModelCustom.updateIsVisitedPlaceEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsVisitedPlaceVisible !== undefined) 
				self.viewModelCustom.updateIsVisitedPlaceVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsVisitedPlacesEnabled !== undefined) 
				self.viewModelCustom.updateIsVisitedPlacesEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsVisitedPlacesVisible !== undefined) 
				self.viewModelCustom.updateIsVisitedPlacesVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsCountryDetailsEnabled !== undefined) 
				self.viewModelCustom.updateIsCountryDetailsEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsCountryDetailsVisible !== undefined) 
				self.viewModelCustom.updateIsCountryDetailsVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsLocationsEnabled !== undefined) 
				self.viewModelCustom.updateIsLocationsEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsLocationsVisible !== undefined) 
				self.viewModelCustom.updateIsLocationsVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsUsersEnabled !== undefined) 
				self.viewModelCustom.updateIsUsersEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsUsersVisible !== undefined) 
				self.viewModelCustom.updateIsUsersVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsMyProfileEnabled !== undefined) 
				self.viewModelCustom.updateIsMyProfileEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsMyProfileVisible !== undefined) 
				self.viewModelCustom.updateIsMyProfileVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsPlacesEnabled !== undefined) 
				self.viewModelCustom.updateIsPlacesEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsPlacesVisible !== undefined) 
				self.viewModelCustom.updateIsPlacesVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsUserProfileEnabled !== undefined) 
				self.viewModelCustom.updateIsUserProfileEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsUserProfileVisible !== undefined) 
				self.viewModelCustom.updateIsUserProfileVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsPlaceDetailsEnabled !== undefined) 
				self.viewModelCustom.updateIsPlaceDetailsEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsPlaceDetailsVisible !== undefined) 
				self.viewModelCustom.updateIsPlaceDetailsVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsLocationDetailsEnabled !== undefined) 
				self.viewModelCustom.updateIsLocationDetailsEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsLocationDetailsVisible !== undefined) 
				self.viewModelCustom.updateIsLocationDetailsVisible();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsCountriesEnabled !== undefined) 
				self.viewModelCustom.updateIsCountriesEnabled();

			if (self.viewModelCustom !== undefined && self.viewModelCustom.updateIsCountriesVisible !== undefined) 
				self.viewModelCustom.updateIsCountriesVisible();

		};

        this.commands = {        
			navigateTo: function (viewName) {
                GO.removeAllFiltersFromQueryStringFromUrl();
				self.controller.navigateTo(viewName);
			},

            navigateToUrl: function (breadcrumb) {
                if (breadcrumb.isactive) {
					window.location.hash = breadcrumb.hash;
                    GO.removeAllFiltersFromQueryStringFromUrl(); 
                }
            }
		};


        this.security = {
            isLoggedIn: ko.observable(false),
			jwtToken: ko.observable(null),
			currentUserClaims: ko.observable(null),
            logOut: function () {
                self.logOut();
            }
        };

		this.security.currentUserName = ko.computed( function() {
			return self.security.currentUserClaims() == null ? null : self.security.currentUserClaims().unique_name;
		});
        
        this.onLogOut = function (data, reason) {		
			solid.auth.logout();
 			$.removeCookie("BearerToken");
			self.security.jwtToken(null);
			self.security.currentUserClaims(null);
			self.security.isLoggedIn(false);
			self.controller.redirectToLoginPage(reason, true);
        };

        this.logOut = function (reason) {
            var configuration = {
                contextId: self.contextId,
				useCookies: true,
                successHandler: function (data) { self.onLogOut(data, reason); },
                errorHandler: self.onLogOut
            };

            self.controller.getProxyForComponent("GOSecurityProvider").LogOut(configuration);
        };
 
		this.securityTimer = {
			automaticDisconnectTimer: null,
			automaticDisconnectMessageTimer: null,
			automaticDisconnectDelay: 1800, // 30 minutes
			automaticDisconnectMessageDelay: 1500, // 25 minutes
			lastClickDate: null
		};

        this.resetSecurityTimer = function () {
            $.jGrowl("close");

			if (Solid.Web.Application.SessionTokenTimeout)
                self.securityTimer.automaticDisconnectDelay = Solid.Web.Application.SessionTokenTimeout;

            if (Solid.Web.Application.SessionNoActivityMessageDelay)
                self.securityTimer.automaticDisconnectMessageDelay = Solid.Web.Application.SessionNoActivityMessageDelay;

			// If the message is displayed, we try to renew the token 
            if ((new Date() - self.securityTimer.lastClickDate) / 1000 >= self.securityTimer.automaticDisconnectMessageDelay) {
				self.controller.getProxyForComponent("GOSecurityProvider").KeepAlive({});
            }

            self.securityTimer.lastClickDate = new Date();      

            // Clearing previous timer
            if (self.securityTimer.automaticDisconnectTimer != null) {
                clearTimeout(self.securityTimer.automaticDisconnectTimer);
            }
            if (self.securityTimer.automaticDisconnectMessageTimer != null) {
                clearTimeout(self.securityTimer.automaticDisconnectMessageTimer);
            }

            // Setting Disconnection Timer
            self.securityTimer.automaticDisconnectTimer = setTimeout(function () {
                self.logOut("noActivityLogOut");
            }, self.securityTimer.automaticDisconnectDelay * 1000);

            // Setting notification Timer
            self.securityTimer.automaticDisconnectMessageTimer = setTimeout(function () {                
                var message = Solid.Web.Messages.warningNoActivity;
				var diffSeconds = self.automaticDisconnectDelay - self.automaticDisconnectMessageDelay;
                $.jGrowl(message, { life: diffSeconds * 1000 });
            }, self.securityTimer.automaticDisconnectMessageDelay * 1000);
        };

		/// Node Visibility
        this.defaultNodeVisibility = false;

		/// Summary of the permissioning logic:
		/// User is in at least one authorizing role for the resource => authorised
		/// All User roles are denied access to the resource => denied
		/// Else the default access setting for the resource is used. (so e.g. if no rules for this role, or if not all roles explicitly denied, then the default is used)
		this.getNodeVisibility = function (nodeName) {
            var currentClaims = self.security.currentUserClaims() == null ? null : self.security.currentUserClaims();
            if (currentClaims !== null) {
                var currentRoles = currentClaims.role.split(',');

				switch (nodeName)
				{
					default:
						break;
				}
			}

			// If we get here, it means there is no explicit (override) node authorization rule for at least one of the user's roles
			// So use the default setting
			return self.defaultNodeVisibility;
		};
			
		this.updateDefaultNavigationNodeVisibility = function () {
            var visibility = false;
			var currentClaims = self.security.currentUserClaims() == null ? null : self.security.currentUserClaims();
            if (currentClaims !== null) {
				var currentRoles = currentClaims.role.split(',');
				if (currentRoles.indexOf('Administrator') > -1 || currentRoles.indexOf('User') > -1) {
					visibility = true;
				}
			} 
			this.defaultNodeVisibility = visibility;
		};

 
		this.updateMenu = function () {
			self.navigation.updateMenu ();
			if(self.viewModelCustom !== undefined && self.viewModelCustom.updateMenu !== undefined)
				self.viewModelCustom.updateMenu();
		};

        this.initialize = function () {
			var token = $.cookie("BearerToken");
			if (token != undefined) {
				self.security.jwtToken(token);
				self.security.currentUserClaims(GO.deconstructJWT(token));
				self.security.isLoggedIn(true);
				self.resetSecurityTimer();
			}
			else {
				self.security.jwtToken(null);
				self.security.currentUserClaims(null);
				self.security.isLoggedIn(false);
			}
			$("body").click(self.resetSecurityTimer);
			
			if (self.viewModelCustom !== undefined && self.viewModelCustom.initialize !== undefined) {
			    self.viewModelCustom.initialize();
			}
			solid.auth.trackSession(session => {
                if (!session) {
                    self.security.logOut();
                }
            });
            
			self.navigation.updateMenu();
		};

        this.release = function () {
            ko.cleanNode($('#form')[0]);
        };

		this.initialize();

        ko.applyBindings(self, $('#form')[0]);        
    };
} (window));

