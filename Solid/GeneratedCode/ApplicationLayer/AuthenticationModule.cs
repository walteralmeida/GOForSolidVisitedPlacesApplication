////////////////////////////////////////////////////////////////////////////////////////////
// This is Generated Code
// You should not modify this code as it may be overwritten. Use Partial classes instead
// Generated By Generative Objects  
//////////////////////////////////////////////////////////////////////////////////////////// 
using GenerativeObjects.Practices.DependencyInjection;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using System.Web;
using System.Configuration;
using Unity;
using GenerativeObjects.Practices.LayerSupportClasses;
using GenerativeObjects.Practices.ExceptionHandling;
using Solid.Feature.Security.Common;
using Solid.BusinessLayer.Components.Server;
using GenerativeObjects.Practices.LayerSupportClasses.Features.Security.Common;
using GenerativeObjects.Practices.LayerSupportClasses.Features.Threading;
using GenerativeObjects.Practices.LayerSupportClasses.ServiceLayer.Http;
using static GenerativeObjects.Practices.LayerSupportClasses.ApplicationSettings.Constants;

namespace Solid.ApplicationLayer.HttpModules
{ 
    public class AuthenticationModule : IHttpModule
    {
        public void Init(HttpApplication context)
        {
            context.BeginRequest += Application_BeginRequest_BeforeAuthenticateGetDbKey;
            context.BeginRequest += Application_BeginRequest;
            context.EndRequest += Application_EndRequest;
        }

        private void Application_BeginRequest_BeforeAuthenticateGetDbKey(object source, EventArgs e)
        {
            var context = (source as HttpApplication).Context;

            var apiRequest = new ApiRequest(context);
            var isApi = context.Request.Path.ToLower().Contains("/api/");
            if (apiRequest.DbKey != null && isApi)
            {
                ApplicationSettings.Container.Resolve<IThreadContext>().DbKey = apiRequest.DbKey;
            }
            else
            {
                if (isApi)
                {
                    ApplicationSettings.Container.Resolve<IThreadContext>().DbKey = null;
                    //dbKey null and API THEN default connection string
                }
            }
        }

        private void Application_BeginRequest(Object source, EventArgs e)
        {
			HttpApplication application = source as HttpApplication;
			HttpContext context = application.Context;

			var authentication = ApplicationSettings.Container.Resolve<IAuthentication>();

			BearerTokenTransport tokenTransport;
			var bearerToken = authentication.GetBearerToken(context, out tokenTransport);

			if (bearerToken == null)        // No user security token 
			{
				HandleNullToken(application);
			}
			else
			{
				// If we get here, there is (well, was) a valid security token at some time prior to the current request
				// Try to Validate (and if needed, refresh) the token
				try
				{
					authentication.ValidateTokenAndAutoRenewTokenIfRequired(bearerToken, tokenTransport);
					HandleValidToken(application);
				}
				catch (System.ServiceModel.Security.ExpiredSecurityTokenException)
				{
					HandleInvalidToken(application, "expiredSecurityToken");
				}
				catch (Exception)
				{
					HandleInvalidToken(application, "invalidSecurityToken");
				}
			}
		}
		
		private void HandleNullToken(HttpApplication application)
		{
			HandleInvalidToken(application, "nullSecurityToken");
		}

		private void HandleInvalidToken(HttpApplication application, string tokenError)
		{
			HttpContext context = application.Context;

			// If url is app baseURL, redirect to log-in page
			if (IsAppBaseUrl(context))
			{
				RedirectToLoginPage(application);
				return;
			}

			// Allow unsecured access to defined targets, e.g. membership
			if (AllowUnauthenticatedAccess(context))
				return;

			// Allow API calls through (entities and components do their own security)
			if (IsAPIRequest(context))
				return;

			// If it's a view navigation, try to authorize it for anonymous access
			if (IsViewNavigation(context))
			{
				if (AuthorizeNavigation(context))
					return;
				else
					RedirectToLoginPage(application);

				return;
			}

			// If get here, access denied. Redirect to landing page. TODO (for now just go to login page)
			RedirectToLoginPage(application);   
		}

		private void HandleValidToken(HttpApplication application)
		{
			HttpContext context = application.Context;

			// If it's a view navigation, check access is authorized
			if (IsViewNavigation(context))
			{
				if (!AuthorizeNavigation(context))
				{ 
					context.Response.StatusCode = (int)HttpStatusCode.Forbidden;
					application.CompleteRequest();
				}
			}
		}
		
		private bool AllowUnauthenticatedAccess(HttpContext context)
		{
			string host = context.Request.Url.Host;
			string appPath = context.Request.ApplicationPath.TrimEnd('/') + "/";

			string[] anonymousTargets = ConfigurationManager.AppSettings["AnonymousAccessFolders"].Split(',');
            if (anonymousTargets == null || anonymousTargets.Length == 0)
            {
				anonymousTargets = new string[]
				{
					// Default unsecured content - for backwards compatability
					"Styles",
					"Membership"
				};
			}

			string url = System.Text.RegularExpressions.Regex.Replace(context.Request.Url.ToString(), @"/+", @"/").ToLower();
			int portNumber = context.Request.Url.Port;
			string port = url.Contains($":{portNumber}") ? $":{portNumber}" : "";
			string referrer = context.Request.UrlReferrer != null ? System.Text.RegularExpressions.Regex.Replace(context.Request.UrlReferrer.ToString(), @"/+", @"/").ToLower() : null;

			foreach (string t in anonymousTargets)
			{
				string target = ($"{host}{port}{appPath}{t.Trim(' ')}").ToLower();
				if (url.Contains(target) || (referrer != null && referrer.Contains(target)))
				{
					// No security token required to access this resource, allow the request to proceed
					return true;
				}
			}

			return false;
		}

		private bool IsAPIRequest(HttpContext context)
		{
			return context.Request.Url.ToString().ToLower().Contains("/api/");
		}

		bool IsViewNavigation(HttpContext context)
		{
			return context.Request.Url.AbsolutePath.IndexOf("/ConstructedViews/") != -1;
		}

		private bool IsAppBaseUrl(HttpContext context)
		{
			string appPath = context.Request.ApplicationPath.TrimEnd('/') + "/";
			return context.Request.RawUrl == appPath || context.Request.RawUrl == appPath + "?";
		}

		private string GetViewTarget(HttpContext context)
		{
			return IsViewNavigation(context)
				? System.IO.Path.GetFileNameWithoutExtension(context.Request.Url.AbsolutePath).Split('.').First()
				: null;
		}
		
		private bool AuthorizeNavigation(HttpContext context)
		{
			string view = GetViewTarget(context);
			if (!String.IsNullOrEmpty(view))
			{
				List<string> nodes = GetNavigationNodeNames(view);
				if (nodes != null)
				{ 
					foreach (string navigationNode in nodes)
					{
						if (!String.IsNullOrEmpty(navigationNode))
						{
							IGOSecurityProvider security = ApplicationSettings.Container.Resolve<IGOSecurityProvider>();
							if (security == null
								|| security.AuthorizeNavigationTo(navigationNode) != (int)PermissionLevel.Authorized)
							{
								return false;
							}
						}
					}
				}
			}

			return true;
		}

		private List<string> GetNavigationNodeNames(string viewName)
		{
			var result = new List<string>();

			switch (viewName) 
			{
				case "CountryPageView":
					result.Add("CountryDetails");
					break;
				case "LocationItemsPageView":
					result.Add("Locations");
					break;
				case "PlaceToLocationPageView":
					result.Add("PlaceToLocationDetails");
					break;
				case "PlaceToLocationItemsPageView":
					result.Add("PlaceToLocations");
					break;
				case "PlaceItemsPageView":
					result.Add("Places");
					break;
				case "PlacePageView":
					result.Add("PlaceDetails");
					break;
				case "LocationPageView":
					result.Add("LocationDetails");
					break;
				case "CountryItemsPageView":
					result.Add("Countries");
					break;
				default:
					return null;
			}

			return result;
		}

		private void RedirectToLoginPage(HttpApplication application)
		{
			HttpContext context = application.Context;
			string appPath = context.Request.ApplicationPath.TrimEnd('/') + "/";
			string loginUrl = appPath + "Membership/Login.html";
			
			var apiRequest = new ApiRequest(context);
            if (apiRequest.DbKey != null)
                loginUrl += "?dbKey=" + apiRequest.DbKey;

            context.Response.Redirect(loginUrl);
			application.CompleteRequest();
		}

		private void WriteErrorResponse(HttpApplication application, HttpStatusCode status, string reason)
		{
			HttpContext context = application.Context;
			context.Response.ContentType = "application/json";
			context.Response.ContentEncoding = Encoding.UTF8;
			context.Response.StatusCode = (int)status;
			string response = GOServerException.FormatJsonResponseString((int)status, reason, reason);  // Setting message = reason partly for backwards compatibility, mainly. Probably more correct to send empty message string here.
			context.Response.Write(response);
			application.CompleteRequest();
		}

        private void Application_EndRequest(Object source, EventArgs e)
        {
			HttpApplication application = source as HttpApplication;
            HttpContext context = application.Context;

            // For some reason, the Set-Cookie Response header is written several times with the same value for the renewed BearerToken
            // Probably an IIS bug
            // https://stackoverflow.com/questions/16630191/asp-net-cookies-bug-multiple-cookies-duplicated-randomly
            // suggests the following workaround just before ending the request: creating a dummy cookie & remove it right away to force
            // a last output of the Response header (with only one occurence of each Set-Cookie per cookie).
            try
            {
                var guid = Guid.NewGuid();
                context.Response.Cookies.Add(new HttpCookie(guid.ToString(), string.Empty));
                context.Response.Cookies.Remove(guid.ToString());
            }
            catch (HttpException)
            {
                //This means the headers were already written,
                //in which case we need not do anything.
            }
        }

        public void Dispose()
        {
        }
    }
}





 